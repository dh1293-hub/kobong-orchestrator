from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime, timezone
import json, uuid, os, socket, threading

def _now():
    return datetime.now(timezone.utc).astimezone()

def _tz_id() -> str:
    # 우선순위: APP_TZ > TZ > 기본 'Asia/Seoul'
    return os.getenv("APP_TZ") or os.getenv("TZ") or "Asia/Seoul"

def _app_obj(name_fallback: str, module: Optional[str]) -> Dict[str, Optional[str]]:
    name = module if module is not None else (name_fallback or "kobong-orchestrator")
    ver = os.getenv("APP_VER") or os.getenv("APP_VERSION") or "0.0.0"
    commit = os.getenv("APP_COMMIT") or os.getenv("GIT_COMMIT") or None
    return {"name": name, "ver": ver, "commit": commit}

@dataclass
class JsonLogger:
    app: str = "kobong-orchestrator"
    env: Optional[str] = None

    def make_record(
        self,
        level: str = "INFO",
        action: str = "contract-test",
        message: str = "",
        *,
        module: Optional[str] = None,         # maps to app.name
        action_step: Optional[int] = None,
        result_status: Optional[str] = None,   # maps to 'result'
        result_code: Optional[int] = None,
        duration_ms: Optional[int] = None,     # legacy alias → latency_ms
        latency_ms: Optional[int] = None,
        env: Optional[str] = None,
        trace_id: Optional[str] = None,
        extra: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> Dict[str, Any]:
        dt = _now()
        rec: Dict[str, Any] = {
            "timestamp": dt.isoformat(),
            "tz": _tz_id(),
            "level": str(level).upper(),
            "app": _app_obj(self.app, module),
            "env": env if env is not None else (self.env or os.getenv("APP_ENV") or os.getenv("ENV") or os.getenv("NODE_ENV") or "local"),
            "host": socket.gethostname(),
            "pid": os.getpid(),
            "thread": threading.current_thread().name,
            "trace_id": trace_id or str(uuid.uuid4()),
            "action": action,
            "result": (
                result_status
                if result_status is not None
                else (kwargs.get("result") if kwargs.get("result") is not None else ("ok" if result_code == 0 else "unknown"))
            ),
            "latency_ms": int(latency_ms if latency_ms is not None else (duration_ms if duration_ms is not None else 0)),
            "message": message,
        }
        if action_step is not None:
            rec["action_step"] = action_step
        if result_code is not None:
            rec["result_code"] = int(result_code)

        if extra:
            rec.update(extra)
        for k, v in kwargs.items():
            if k not in rec:
                rec[k] = v
        return rec

    def log(self, message: str = "", level: str = "INFO", action: str = "contract-test", **kwargs):
        return self.make_record(level=level, action=action, message=message, **kwargs)

    def record(self, *args, **kwargs): return self.make_record(*args, **kwargs)
    def create(self, *args, **kwargs): return self.make_record(*args, **kwargs)

    def to_json(self, **kwargs) -> str:
        return json.dumps(self.make_record(**kwargs), ensure_ascii=False)
