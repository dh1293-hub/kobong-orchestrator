from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime, timezone
import json, uuid

def _iso_now() -> str:
    # ISO8601 with local offset
    return datetime.now(timezone.utc).astimezone().isoformat()

@dataclass
class JsonLogger:
    module: str = "kobong-orchestrator"
    env: Optional[str] = None

    def make_record(
        self,
        level: str = "INFO",
        action: str = "contract-test",
        message: str = "",
        *,
        errorCode: Optional[str] = None,
        durationMs: Optional[int] = None,
        traceId: Optional[str] = None,
        outcome: Optional[str] = None,
        extra: Optional[Dict[str, Any]] = None,
        env: Optional[str] = None,
    ) -> Dict[str, Any]:
        rec: Dict[str, Any] = {
            "timestamp": _iso_now(),
            "level": str(level).upper(),
            "module": self.module,
            "action": action,
            "message": message,
            "errorCode": errorCode or "",
            "durationMs": int(durationMs) if durationMs is not None else None,
            "traceId": traceId or str(uuid.uuid4()),
            "outcome": outcome or "",
        }
        # include env if provided (argument wins over instance)
        _env = env if env is not None else self.env
        if _env:
            rec["env"] = _env
        if extra:
            # extra fields merge last
            rec.update(extra)
        return rec

    # Friendly helpers expected by tests
    def log(self, message: str = "", level: str = "INFO", action: str = "contract-test", **kwargs):
        return self.make_record(level=level, action=action, message=message, **kwargs)

    def record(self, *args, **kwargs): return self.make_record(*args, **kwargs)
    def create(self, *args, **kwargs): return self.make_record(*args, **kwargs)

    def to_json(self, **kwargs) -> str:
        return json.dumps(self.make_record(**kwargs), ensure_ascii=False)
