from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime, timezone
import json, uuid, os, socket, threading

def _now():
    return datetime.now(timezone.utc).astimezone()

def _tz_id() -> str:
    return os.getenv("APP_TZ") or os.getenv("TZ") or "Asia/Seoul"

def _app_obj(name_fallback: str, module: Optional[str]) -> Dict[str, Optional[str]]:
    name = module if module is not None else (name_fallback or "kobong-orchestrator")
    ver = os.getenv("APP_VER") or os.getenv("APP_VERSION") or "0.0.0"
    commit = os.getenv("APP_COMMIT") or os.getenv("GIT_COMMIT") or None
    return {"name": name, "ver": ver, "commit": commit}

_STATUS_TO_CODE = {
    "ok": 0,
    "retry": 1,
    "timeout": 2,
    "assert_fail": 3,
    "cancel": 4,
    "fatal": 9,
}
_CODE_TO_STATUS = {v: k for k, v in _STATUS_TO_CODE.items()}

def _result_obj(result_status: Optional[str], result_code: Optional[int], fallback_ok: bool = True) -> Dict[str, Any]:
    status = (result_status or "").strip().lower() if result_status else None
    code = int(result_code) if result_code is not None else None
    if status and code is None:
        code = _STATUS_TO_CODE.get(status, 9)
    if code is not None and not status:
        status = _CODE_TO_STATUS.get(int(code), "fatal")
    if status is None and code is None:
        status = "ok" if fallback_ok else "fatal"
        code = _STATUS_TO_CODE[status]
    return {"status": status, "code": int(code)}

@dataclass
class JsonLogger:
    app: str = "kobong-orchestrator"
    env: Optional[str] = None

    def make_record(
        self,
        level: str = "INFO",
        action: str = "contract-test",   # kept for API compat, not stored directly
        message: str = "",
        *,
        module: Optional[str] = None,         # -> app.name
        action_step: Optional[int] = None,    # -> action.step
        dsl_id: Optional[str] = None,         # -> action.dsl_id
        result_status: Optional[str] = None,  # -> result.status
        result_code: Optional[int] = None,    # -> result.code
        duration_ms: Optional[int] = None,    # legacy alias -> latency_ms
        latency_ms: Optional[int] = None,
        env: Optional[str] = None,
        trace_id: Optional[str] = None,
        extra: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> Dict[str, Any]:
        dt = _now()
        rec: Dict[str, Any] = {
            "timestamp": dt.isoformat(),
            "tz": _tz_id(),
            "level": str(level).upper(),
            "app": _app_obj(self.app, module),
            "env": env if env is not None else (self.env or os.getenv("APP_ENV") or os.getenv("ENV") or os.getenv("NODE_ENV") or "local"),
            "host": socket.gethostname(),
            "pid": os.getpid(),
            "thread": threading.current_thread().name,
            "trace_id": trace_id or str(uuid.uuid4()),
            "action": {"step": int(action_step if action_step is not None else (kwargs.get("step") or 0)), "dsl_id": dsl_id if dsl_id is not None else kwargs.get("dsl_id")},
            "result": _result_obj(result_status, result_code),
            "latency_ms": int(latency_ms if latency_ms is not None else (duration_ms if duration_ms is not None else 0)),
            "message": message,
        }
        if extra:
            # avoid clobbering required structured fields
            for k, v in extra.items():
                if k not in ("app", "action", "result"):
                    rec[k] = v
        for k, v in kwargs.items():
            if k not in rec and k not in ("app", "action", "result"):
                rec[k] = v
        return rec

    def log(self, message: str = "", level: str = "INFO", action: str = "contract-test", **kwargs):
        return self.make_record(level=level, action=action, message=message, **kwargs)

    def record(self, *args, **kwargs): return self.make_record(*args, **kwargs)
    def create(self, *args, **kwargs): return self.make_record(*args, **kwargs)

    def to_json(self, **kwargs) -> str:
        return json.dumps(self.make_record(**kwargs), ensure_ascii=False)
