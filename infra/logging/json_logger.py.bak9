from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime, timezone
import json, uuid

def _iso_now() -> str:
    # local timezone ISO8601 (with offset)
    return datetime.now(timezone.utc).astimezone().isoformat()

@dataclass
class JsonLogger:
    module: str = "kobong-orchestrator"

    def make_record(
        self,
        level: str,
        action: str,
        message: str = "",
        *,
        errorCode: Optional[str] = None,
        durationMs: Optional[int] = None,
        traceId: Optional[str] = None,
        outcome: Optional[str] = None,
        extra: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        rec: Dict[str, Any] = {
            "timestamp": _iso_now(),
            "level": str(level).upper(),
            "module": self.module,
            "action": action,
            "message": message,
            "errorCode": errorCode or "",
            "durationMs": int(durationMs) if durationMs is not None else None,
            "traceId": traceId or str(uuid.uuid4()),
            "outcome": outcome or "",
        }
        if extra:
            rec.update(extra)
        return rec

    # common aliases to be flexible with tests
    def log(self, *args, **kwargs): return self.make_record(*args, **kwargs)
    def record(self, *args, **kwargs): return self.make_record(*args, **kwargs)
    def create(self, *args, **kwargs): return self.make_record(*args, **kwargs)

    def to_json(self, *args, **kwargs) -> str:
        return json.dumps(self.make_record(*args, **kwargs), ensure_ascii=False)
