# Code-REP-001
# Name: ps-hardening.scan-and-patch.ps1
# Version: 1.2.2
# Intent: Repo-wide PS scripts hardening — add StrictMode/Stop and _preamble dot-source; report '??' usage.
# Preconditions: Git repo or script under repo; write access to repo
# Effects: (Apply only) Inserts standard header lines into .ps1 under scripts/. Creates .bak backups. Writes logs/apply-log.jsonl
# Rollback: Restore *.bak or `git checkout -- <file>`
# Idempotency: Re-running produces same result; already-patched files are skipped
# Order: Run before other wide refactors. One intent only (headers + report)
# Post-verify: Check console summary and logs/apply-log.jsonl
# APPLY IN SHELL

param(
  [switch] $DryRun,
  [switch] $ConfirmApply,
  [int]    $TimeoutSec = 90,
  [int]    $MaxFiles   = 5000,
  [int]    $MaxDepth   = 12,
  [switch] $NoForceExit,
  [switch] $ForceKill
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
$ProgressPreference = 'SilentlyContinue'

function Get-GitRoot { try { git rev-parse --show-toplevel 2>$null } catch { $null } }
$RepoRoot = Get-GitRoot
if (-not $RepoRoot) { $RepoRoot = (Resolve-Path (Join-Path $PSScriptRoot '..')).Path }
if (-not (Test-Path $RepoRoot)) { throw "PRECONDITION: RepoRoot not found" }

# Lock
$LockFile = Join-Path $RepoRoot '.gpt5.lock'
if (Test-Path $LockFile) { throw 'CONFLICT: Another operation in progress (.gpt5.lock exists).' }
'locked ' + (Get-Date).ToString('o') | Out-File $LockFile -Encoding utf8 -NoNewline

# Logging
$LogsDir = Join-Path $RepoRoot 'logs'
New-Item -ItemType Directory -Force -Path $LogsDir | Out-Null
$Jsonl = Join-Path $LogsDir 'apply-log.jsonl'
function Write-JsonLog {
  param([string]$Action,[string]$Outcome,[string]$Message = '',[string]$ErrorCode = '',[int]$DurationMs = 0)
  $obj = [ordered]@{
    timestamp=(Get-Date).ToString('o'); level=$(if($Outcome -eq 'FAILURE'){'ERROR'}else{'INFO'})
    traceId=[guid]::NewGuid().ToString(); module='scripts'; action=$Action; inputHash=''
    outcome=$Outcome; durationMs=$DurationMs; errorCode=$ErrorCode; message=$Message
  }
  $line = ($obj | ConvertTo-Json -Depth 6 -Compress)
  if (-not (Test-Path $Jsonl)) { $line | Out-File -FilePath $Jsonl -Encoding utf8 } else { $line | Out-File -FilePath $Jsonl -Encoding utf8 -Append }
}

# Ignore rules
$IgnoreDirs = @('\.git\','\node_modules\','\out\','\.venv\','\.cache\','\dist\','\coverage\','\target\','\bin\','\obj\')
function Should-SkipPath([string]$p){ $pp = $p -ireplace '/', '\'; foreach($i in $IgnoreDirs){ if($pp -match $i){ return $true } }; return $false }

# Bounded enumerator
function Get-Ps1Files([string]$root,[int]$maxDepth,[int]$maxFiles,[int]$timeoutSec,[ref]$truncated){
  $truncated.Value = $false
  $results = New-Object System.Collections.Generic.List[System.IO.FileInfo]
  $visited = New-Object 'System.Collections.Generic.HashSet[string]'
  $queue   = New-Object 'System.Collections.Generic.Queue[psobject]'
  $sw      = [System.Diagnostics.Stopwatch]::StartNew()

  $rootItem = Get-Item -LiteralPath $root -ErrorAction SilentlyContinue
  if (-not $rootItem) { return $results }
  $queue.Enqueue([pscustomobject]@{ Dir=$rootItem; Depth=0 })

  while($queue.Count -gt 0){
    if ($sw.Elapsed.TotalSeconds -ge $timeoutSec) { $truncated.Value = $true; break }
    if ($results.Count -ge $maxFiles) { $truncated.Value = $true; break }

    $node = $queue.Dequeue()
    $dir  = $node.Dir
    $depth= [int]$node.Depth

    $norm = ($dir.FullName -ireplace '/', '\').ToLowerInvariant()
    if ($visited.Contains($norm)) { continue }
    [void]$visited.Add($norm)

    if ($dir.Attributes -band [IO.FileAttributes]::ReparsePoint) { continue }
    if (Should-SkipPath $dir.FullName) { continue }

    try {
      $files = Get-ChildItem -LiteralPath $dir.FullName -Filter *.ps1 -File -ErrorAction SilentlyContinue
      foreach($f in $files){
        $results.Add($f) | Out-Null
        if ($results.Count -ge $maxFiles) { $truncated.Value = $true; break }
      }
      if ($truncated.Value) { break }
    } catch {}

    if ($depth -ge $maxDepth) { continue }
    try {
      $dirs = Get-ChildItem -LiteralPath $dir.FullName -Directory -Force -ErrorAction SilentlyContinue
      foreach($d in $dirs){
        if ($d.Attributes -band [IO.FileAttributes]::ReparsePoint) { continue }
        if (Should-SkipPath $d.FullName) { continue }
        $queue.Enqueue([pscustomobject]@{ Dir=$d; Depth=($depth+1) })
      }
    } catch {}
  }
  return $results
}

# Header template
$HeaderLines = @(
  "Set-StrictMode -Version Latest",
  "$" + "ErrorActionPreference = 'Stop'",
  ". `"$PSScriptRoot\_preamble.ps1`"  # dot-source if exists; harmless if file absent (guarded in preamble)
)
function Normalize-Newline([string]$s){ return ($s -replace "`r`n","`n") }
function Ensure-Header([string]$content) {
  $needs = @(); foreach($h in $HeaderLines){ if ($content -notmatch [regex]::Escape($h)) { $needs += $h } }
  if ($needs.Count -eq 0) { return $content }
  $nl = "`r`n"
  $lines = $content -split "`r?`n"
  $insertAt = 0
  if ($lines.Count -gt 0 -and $lines[0] -match '^\s*#\!') { $insertAt = 1 }
  if ($lines.Count -gt 0 -and $lines[0] -match '^\s*param\s*\(') {
    $depth=0; for($i=0;$i -lt $lines.Count;$i++){ if($lines[$i] -match '\('){$depth++}; if($lines[$i] -match '\)'){ $depth--; if($depth -le 0){ $insertAt=$i+1; break } } }
  }
  $prefix = $lines[0..($insertAt-1)]
  $suffix = $lines[$insertAt..($lines.Count-1)]
  $injected = @(); foreach($h in $needs){ $injected += $h }
  $newLines = @(); $newLines += $prefix
  if ($injected.Count -gt 0) { if ($prefix.Count -gt 0) { $newLines += "" }; $newLines += $injected }
  if ($suffix.Count -gt 0) { if ($injected.Count -gt 0) { $newLines += "" }; $newLines += $suffix }
  return ($newLines -join $nl)
}

function Invoke-StrongExit {
  param([switch]$ForceKill)
  try { $global:LASTEXITCODE = 0 } catch {}
  try { if ($host -and $host.UI) { $host.SetShouldExit(0) } } catch {}
  try { exit 0 } catch {}
  try { [Environment]::Exit(0) } catch {}
  if ($ForceKill) { try { Stop-Process -Id $PID -Force } catch {} }
}

# Main
$swAll=[System.Diagnostics.Stopwatch]::StartNew()
$report = @(); $patched=0; $skipped=0; $err=0; $trunc=$false

try {
  $ScriptsDir = Join-Path $RepoRoot 'scripts'
  $ScanRoot = $(if (Test-Path $ScriptsDir) { $ScriptsDir } else { $RepoRoot })
  $files = Get-Ps1Files $ScanRoot $MaxDepth $MaxFiles $TimeoutSec ([ref]$trunc)

  foreach($f in $files){
    try {
      $orig = [System.IO.File]::ReadAllText($f.FullName)
      $norm = Normalize-Newline $orig
      $new  = Ensure-Header $norm
      $hasNullCoalesce = ($norm -match '(^|[^\?])\?\?([^\?]|$)')

      if ($new -ne $norm) {
        if ($ConfirmApply) {
          $bak = "$($f.FullName).bak"
          if (-not (Test-Path $bak)) { [System.IO.File]::Copy($f.FullName, $bak, $true) }
          [System.IO.File]::WriteAllText($f.FullName, $new, (New-Object System.Text.UTF8Encoding($false)))
          $patched++; Write-JsonLog -Action "Patch:$($f.Name)" -Outcome 'SUCCESS' -Message 'Header injected'
        } else {
          $skipped++; Write-JsonLog -Action "Preview:$($f.Name)" -Outcome 'DRYRUN' -Message 'Would inject header'
        }
      } else {
        Write-JsonLog -Action "Check:$($f.Name)" -Outcome 'SUCCESS' -Message 'Header OK'
      }

      if ($hasNullCoalesce) {
        $report += [pscustomobject]@{ File=$f.FullName; Issue='?? operator detected (PS5-incompatible)'; Hint='Refactor: if (-not $var) { $var = <fallback> }' }
      }
    } catch {
      $err++; Write-JsonLog -Action "Check:$($f.Name)" -Outcome 'FAILURE' -ErrorCode=$_.Exception.Message -Message=$_.ScriptStackTrace
    }
  }

  $swAll.Stop()
  $summary = "files=$($files.Count) patched=$patched preview=$skipped issues=$($report.Count) truncated=$trunc timeout=${TimeoutSec}s maxFiles=${MaxFiles} maxDepth=${MaxDepth}"
  Write-JsonLog -Action 'RepoHardening' -Outcome $(if($err -gt 0){'FAILURE'}elseif($ConfirmApply){'SUCCESS'}else{'DRYRUN'}) -Message $summary -DurationMs $swAll.ElapsedMilliseconds

  Write-Host "==== PS Hardening Summary ===="
  Write-Host ("Scanned     : {0}" -f $files.Count)
  Write-Host ("Patched     : {0}" -f $patched)
  Write-Host ("PreviewOnly : {0}" -f $skipped)
  Write-Host ("Errors      : {0}" -f $err)
  Write-Host ("Truncated   : {0} (timeout={1}s, maxFiles={2}, maxDepth={3})" -f $trunc,$TimeoutSec,$MaxFiles,$MaxDepth)
  if ($report.Count -gt 0) {
    Write-Host "`nFiles needing manual fix (PS5-incompatible '??'):"
    $report | ForEach-Object { Write-Host " - $($_.File)" }
    Write-Host "`nHint: Replace 'a ?? b' → `n  if (-not $a -or [string]::IsNullOrWhiteSpace($a)) { $a = b }"
  }
}
finally {
  Remove-Item -Force $LockFile -ErrorAction SilentlyContinue
  if ($NoForceExit) { return }
  Invoke-StrongExit -ForceKill:$ForceKill
}