# APPLY IN SHELL
#requires -Version 7.0
param([switch]$ConfirmApply,[string]$Root)
Set-StrictMode -Version Latest
$ErrorActionPreference='Stop'
$PSDefaultParameterValues['Out-File:Encoding']='utf8'
$PSDefaultParameterValues['*:Encoding']='utf8'
if ($env:CONFIRM_APPLY -eq 'true') { $ConfirmApply = $true }

# === Preflight ===
$RepoRoot = if ($Root) { (Resolve-Path -LiteralPath $Root).Path } else { (git rev-parse --show-toplevel 2>$null) ?? (Get-Location).Path }
if (-not (Test-Path $RepoRoot)) { Write-Error "PRECONDITION: RepoRoot not found → $RepoRoot"; exit 10 }
Set-Location $RepoRoot
$Branch = (git rev-parse --abbrev-ref HEAD 2>$null) ?? '<unknown>'
$now = [TimeZoneInfo]::ConvertTimeBySystemTimeZoneId((Get-Date),'Asia/Seoul').ToString('yyyy-MM-dd HH:mm:ss')
Write-Host ("`n[verify] EOL/LF on {0} @ {1} (KST)" -f $Branch,$now)

# === Lock (auto stale unlock >=120s) ===
$LockFile = Join-Path $RepoRoot '.gpt5.lock.eol-guard'
if (Test-Path $LockFile) {
  try { $age = [int]((Get-Date) - (Get-Item $LockFile).LastWriteTime).TotalSeconds } catch { $age = 999999 }
  if ($age -ge 120) {
    $ts  = Get-Date -Format 'yyyyMMdd-HHmmss'
    $rot = "{0}.stale-{1}" -f $LockFile, $ts
    Move-Item -Force $LockFile $rot
    Write-Host ("[auto-unlock] rotated stale lock → {0}" -f $rot)
  } else { Write-Error 'CONFLICT: .gpt5.lock.eol-guard exists (recent)'; exit 11 }
}
"locked $(Get-Date -Format o)" | Out-File $LockFile -Encoding utf8 -NoNewline
$sw=[Diagnostics.Stopwatch]::StartNew()
$trace=[guid]::NewGuid().ToString()
function Write-Log($level,$action,$message,$outcome='',$errorCode='',$inputHash=''){
  $rec=[ordered]@{timestamp=(Get-Date).ToString('o');level=$level;traceId=$trace;module='eol-guard';action=$action;inputHash=$inputHash;outcome=$outcome;durationMs=$sw.ElapsedMilliseconds;errorCode=$errorCode;message=$message}|ConvertTo-Json -Compress
  $log=Join-Path $RepoRoot 'logs/apply-log.jsonl'; New-Item -ItemType Directory -Force -Path (Split-Path $log)|Out-Null; Add-Content -Path $log -Value $rec
}

# === Target sets ===
$skipRx = [regex]'(?i)[/\\](?:\.git|node_modules|dist|out|coverage|\.venv|\.pytest_cache|\.idea|\.vscode)(?:[/\\]|$)'

$toLF   = Get-ChildItem -Recurse -File -Include *.ps1,*.psm1,*.psd1,*.yml,*.yaml,*.json,*.md,*.sh | Where-Object { -not $skipRx.IsMatch($_.FullName) }
$toCRLF = Get-ChildItem -Recurse -File -Include *.cmd | Where-Object { -not $skipRx.IsMatch($_.FullName) }

# === Scan ===
$plan = @()
$rxCRLF = [regex]'`r`n'
$rxLF   = [regex]'(?<!`r)`n'   # bare LF
foreach ($f in $toLF) {
  $raw = Get-Content -Raw -Encoding utf8 $f.FullName
  if ($rxCRLF.IsMatch($raw)) {
    $plan += [pscustomobject]@{ Path=$f.FullName; Mode='LF'; Reason='CRLF→LF' }
    continue
  }
  # (선택) 택1: LF만 있는 경우는 OK로 둠
}
foreach ($f in $toCRLF) {
  $raw = Get-Content -Raw -Encoding utf8 $f.FullName
  if ($rxLF.IsMatch($raw)) {
    $plan += [pscustomobject]@{ Path=$f.FullName; Mode='CRLF'; Reason='LF→CRLF for .cmd' }
    continue
  }
}

# .gitattributes 확인/보강
$AttrPath = Join-Path $RepoRoot '.gitattributes'
$needAttr = $false
$attrWanted = @(
  "* text=auto eol=lf",
  "*.ps1 text eol=lf",
  "*.cmd text eol=crlf"
)
if (-not (Test-Path $AttrPath)) {
  $needAttr = $true
} else {
  $cur = Get-Content -Raw -Encoding utf8 $AttrPath
  foreach ($ln in $attrWanted) { if ($cur -notmatch ('(?m)^\Q' + $ln + '\E$')) { $needAttr = $true; break } }
}
if ($needAttr) { $plan += [pscustomobject]@{ Path=$AttrPath; Mode='ATTR'; Reason='ensure .gitattributes' } }

if (-not $plan) {
  Write-Host "✅ 모든 대상 파일의 줄바꿈(EOL)이 정책에 부합합니다."
  Write-Log 'INFO' 'scan' 'all good' 'OK'
  exit 0
}

Write-Host ("📝 교정 대상 {0}개" -f $plan.Count)
$plan | Select-Object -First 10 | ForEach-Object { Write-Host (" - {0} :: {1}" -f $_.Path, $_.Reason) }
if ($plan.Count -gt 10) { Write-Host ("   (+ {0} more ...)" -f ($plan.Count - 10)) }

if (-not $ConfirmApply) {
  Write-Host "`nDRY-RUN ✅ 실제 수정은 하지 않았습니다."
  Write-Host "적용하려면:"
  Write-Host "  `$env:CONFIRM_APPLY='true'; pwsh -File scripts/g5/guard-eol-lf.ps1 -ConfirmApply"
  Write-Log 'INFO' 'dryrun' ("would fix {0} files" -f $plan.Count) 'NOT_APPLIED'
  exit 0
}

# === Apply (backup + atomic replace) ===
$ts = Get-Date -Format 'yyyyMMdd-HHmmss'
foreach ($it in $plan) {
  if ($it.Mode -eq 'ATTR') {
    $newAttr = ($attrWanted -join "`n") + "`n"
    if (Test-Path $AttrPath) {
      $bak = "$AttrPath.bak-$ts"; Copy-Item $AttrPath $bak -Force
    }
    $tmp = "$AttrPath.tmp"; Set-Content -Path $tmp -Value $newAttr -Encoding utf8 -NoNewline; Move-Item -Force $tmp $AttrPath
    Write-Log 'INFO' 'apply' "wrote .gitattributes" 'APPLIED' '' ((Test-Path $AttrPath) ? (Get-FileHash $AttrPath -Algorithm SHA256).Hash : '')
    Write-Host "[fixed] .gitattributes — ${if (Test-Path $AttrPath) { "backup: $AttrPath.bak-$ts" } else { 'new file' }}"
    continue
  }

  $p = $it.Path
  $src = Get-Content -Raw -Encoding utf8 $p
  if ($it.Mode -eq 'LF')   { $new = ($src -replace "`r`n","`n") }
  if ($it.Mode -eq 'CRLF') { $new = ($src -replace "`r?`n","`r`n") }

  if ($new -ne $src) {
    $bak = "$p.bak-$ts"; Copy-Item $p $bak -Force
    $tmp = "$p.tmp"; Set-Content -Path $tmp -Value $new -Encoding utf8 -NoNewline; Move-Item -Force $tmp $p
    Write-Log 'INFO' 'apply' ("EOL fixed → {0}" -f $p) 'APPLIED' '' ((Get-FileHash $p -Algorithm SHA256).Hash)
    Write-Host ("[fixed] {0} :: {1}" -f $p, $it.Reason)
  }
}

Write-Host "`nDONE ✅ EOL/LF 교정 완료"
exit 0