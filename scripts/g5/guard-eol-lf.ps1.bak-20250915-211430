# APPLY IN SHELL
#requires -Version 7.0
param([switch]$ConfirmApply,[string]$Root)
Set-StrictMode -Version Latest
$ErrorActionPreference='Stop'
$PSDefaultParameterValues['Out-File:Encoding']='utf8'
$PSDefaultParameterValues['*:Encoding']='utf8'
if ($env:CONFIRM_APPLY -eq 'true') { $ConfirmApply = $true }

# === Preflight ===
$RepoRoot = if ($Root) { (Resolve-Path -LiteralPath $Root).Path } else { (git rev-parse --show-toplevel 2>$null) ?? (Get-Location).Path }
if (-not (Test-Path $RepoRoot)) { Write-Error "PRECONDITION: RepoRoot not found â†’ $RepoRoot"; exit 10 }
Set-Location $RepoRoot
$Branch = (git rev-parse --abbrev-ref HEAD 2>$null) ?? '<unknown>'
$now    = [TimeZoneInfo]::ConvertTimeBySystemTimeZoneId((Get-Date),'Asia/Seoul').ToString('yyyy-MM-dd HH:mm:ss')
Write-Host ("`n[verify] EOL/LF on {0} @ {1} (KST)" -f $Branch,$now)

# === Lock (auto stale unlock >=120s) ===
$LockFile = Join-Path $RepoRoot '.gpt5.lock.eol-guard'
if (Test-Path $LockFile) {
  try { $age = [int]((Get-Date) - (Get-Item $LockFile).LastWriteTime).TotalSeconds } catch { $age = 999999 }
  if ($age -ge 120) {
    $ts  = Get-Date -Format 'yyyyMMdd-HHmmss'
    $rot = "{0}.stale-{1}" -f $LockFile, $ts
    Move-Item -Force $LockFile $rot
    Write-Host ("[auto-unlock] rotated stale lock â†’ {0}" -f $rot)
  } else { Write-Error 'CONFLICT: .gpt5.lock.eol-guard exists (recent)'; exit 11 }
}
"locked $(Get-Date -Format o)" | Out-File $LockFile -Encoding utf8 -NoNewline
$sw=[Diagnostics.Stopwatch]::StartNew()
$trace=[guid]::NewGuid().ToString()
function Write-Log($level,$action,$message,$outcome='',$errorCode='',$inputHash=''){
  $rec=[ordered]@{timestamp=(Get-Date).ToString('o');level=$level;traceId=$trace;module='eol-guard';action=$action;inputHash=$inputHash;outcome=$outcome;durationMs=$sw.ElapsedMilliseconds;errorCode=$errorCode;message=$message}|ConvertTo-Json -Compress
  $log=Join-Path $RepoRoot 'logs/apply-log.jsonl'; New-Item -ItemType Directory -Force -Path (Split-Path $log)|Out-Null; Add-Content -Path $log -Value $rec
}

# === Target sets ===
$skipRx = [regex]'(?i)[/\\](?:\.git|node_modules|dist|out|coverage|\.venv|\.pytest_cache|\.idea|\.vscode)(?:[/\\]|$)'

$toLF   = Get-ChildItem -Recurse -File -Include *.ps1,*.psm1,*.psd1,*.yml,*.yaml,*.json,*.md,*.sh | Where-Object { -not $skipRx.IsMatch($_.FullName) }
$toCRLF = Get-ChildItem -Recurse -File -Include *.cmd | Where-Object { -not $skipRx.IsMatch($_.FullName) }

# === Scan ===
$plan = @()
$rxCRLF = [regex]'`r`n'
$rxLF   = [regex]'(?<!`r)`n'   # bare LF
foreach ($f in $toLF) {
  $raw = Get-Content -Raw -Encoding utf8 $f.FullName
  if ($rxCRLF.IsMatch($raw)) {
    $plan += [pscustomobject]@{ Path=$f.FullName; Mode='LF'; Reason='CRLFâ†’LF' }
    continue
  }
}
foreach ($f in $toCRLF) {
  $raw = Get-Content -Raw -Encoding utf8 $f.FullName
  if ($rxLF.IsMatch($raw)) {
    $plan += [pscustomobject]@{ Path=$f.FullName; Mode='CRLF'; Reason='LFâ†’CRLF for .cmd' }
    continue
  }
}

# .gitattributes í™•ì¸/ë³´ê°• (ë¼ì¸ ë¹„êµ ê¸°ë°˜)
$AttrPath   = Join-Path $RepoRoot '.gitattributes'
$attrWanted = @(
  "* text=auto eol=lf",
  "*.ps1 text eol=lf",
  "*.cmd text eol=crlf"
)

$needAttr      = $false
$missingLines  = @()
$existingAttr  = Test-Path $AttrPath
if (-not $existingAttr) {
  $needAttr = $true
  $missingLines = $attrWanted
} else {
  $curLines = Get-Content -Encoding utf8 $AttrPath | ForEach-Object { $_.TrimEnd() }
  foreach ($ln in $attrWanted) {
    if (-not ($curLines -contains $ln)) { $missingLines += $ln }
  }
  if ($missingLines.Count -gt 0) { $needAttr = $true }
}
if ($needAttr) {
  $reason = if (-not $existingAttr) { 'create .gitattributes' } else { 'append missing rules: ' + ($missingLines -join ', ') }
  $plan += [pscustomobject]@{ Path=$AttrPath; Mode='ATTR'; Reason=$reason; Missing=$missingLines }
}

if (-not $plan) {
  Write-Host "âœ… ëª¨ë“  ëŒ€ìƒ íŒŒì¼ì˜ ì¤„ë°”ê¿ˆ(EOL)ì´ ì •ì±…ì— ë¶€í•©í•©ë‹ˆë‹¤."
  Write-Log 'INFO' 'scan' 'all good' 'OK'
  exit 0
}

Write-Host ("ðŸ“ êµì • ëŒ€ìƒ {0}ê°œ" -f $plan.Count)
$plan | Select-Object -First 10 | ForEach-Object { Write-Host (" - {0} :: {1}" -f $_.Path, $_.Reason) }
if ($plan.Count -gt 10) { Write-Host ("   (+ {0} more ...)" -f ($plan.Count - 10)) }

if (-not $ConfirmApply) {
  Write-Host "`nDRY-RUN âœ… ì‹¤ì œ ìˆ˜ì •ì€ í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
  Write-Host "ì ìš©í•˜ë ¤ë©´:"
  Write-Host "  `$env:CONFIRM_APPLY='true'; pwsh -File scripts/g5/guard-eol-lf.ps1 -ConfirmApply"
  Write-Log 'INFO' 'dryrun' ("would fix {0} files" -f $plan.Count) 'NOT_APPLIED'
  exit 0
}

# === Apply (backup + atomic replace) ===
$ts = Get-Date -Format 'yyyyMMdd-HHmmss'
foreach ($it in $plan) {
  if ($it.Mode -eq 'ATTR') {
    $wasExisting = Test-Path $AttrPath
    if ($wasExisting) {
      $curLines = Get-Content -Encoding utf8 $AttrPath | ForEach-Object { $_.TrimEnd() }
      $newAttr  = ($curLines + $it.Missing) -join "`n"
      $newAttr += "`n"
      $bak = "$AttrPath.bak-$ts"; Copy-Item $AttrPath $bak -Force
      $tmp = "$AttrPath.tmp"; Set-Content -Path $tmp -Value $newAttr -Encoding utf8 -NoNewline; Move-Item -Force $tmp $AttrPath
      Write-Log 'INFO' 'apply' "appended to .gitattributes" 'APPLIED' '' ((Get-FileHash $AttrPath -Algorithm SHA256).Hash)
      Write-Host ("[fixed] .gitattributes â€” appended ({0}) â€” backup: {1}" -f ($it.Missing -join ', '), $bak)
    } else {
      $newAttr = ($attrWanted -join "`n") + "`n"
      $tmp = "$AttrPath.tmp"; Set-Content -Path $tmp -Value $newAttr -Encoding utf8 -NoNewline; Move-Item -Force $tmp $AttrPath
      Write-Log 'INFO' 'apply' "created .gitattributes" 'APPLIED' '' ((Get-FileHash $AttrPath -Algorithm SHA256).Hash)
      Write-Host "[fixed] .gitattributes â€” new file"
    }
    continue
  }

  $p = $it.Path
  $src = Get-Content -Raw -Encoding utf8 $p
  if ($it.Mode -eq 'LF')   { $new = ($src -replace "`r`n","`n") }
  if ($it.Mode -eq 'CRLF') { $new = ($src -replace "`r?`n","`r`n") }

  if ($new -ne $src) {
    $bak = "$p.bak-$ts"; Copy-Item $p $bak -Force
    $tmp = "$p.tmp"; Set-Content -Path $tmp -Value $new -Encoding utf8 -NoNewline; Move-Item -Force $tmp $p
    Write-Log 'INFO' 'apply' ("EOL fixed â†’ {0}" -f $p) 'APPLIED' '' ((Get-FileHash $p -Algorithm SHA256).Hash)
    Write-Host ("[fixed] {0} :: {1}" -f $p, $it.Reason)
  }
}

Write-Host "`nDONE âœ… EOL/LF êµì • ì™„ë£Œ"
exit 0